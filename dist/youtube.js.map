{"version":3,"sources":["../src/youtube.js"],"names":["loadVideo","YouTubeReader","constructor","id","host","getAdaptiveFmt","html","result","match","adaptiveFmtReg","getFmt","data","parse","replace","JSON","stringify","availableIndex","type","forEach","item","index","startsWith","push","targets","Promise","all","map","url","itag","quality","quality_label","Array","isArray","split","size","sp","signature","getDecryptedSignature","s","getUrl","catch","e","console","error","resolve","fmtReg","err","destroy","reject","types","t","sig","qualityMap","decrypted","buff","Buffer","from","toString","log","fetchVideo","options","agent","headers","req","res","statusCode","location","targetHeaders","emit","reduce","target","next","on","chunk","end","getDownloadLink","then","_read","_destroy","tm","clearTimeout","setTimeout","name","message","playerJSReg","playerScriptResult","decryptedSig","decrypt","stream"],"mappings":"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","file":"youtube.js","sourcesContent":["import {Readable} from 'stream'\nimport {request} from 'https'\nimport {parse} from 'url'\nimport querystring from 'querystring'\nimport HttpsProxyAgent from 'https-proxy-agent'\nimport {NotFoundError, RequestFailError} from './Errors'\nimport {Signature} from './signature'\nimport {proxy, watchUrl} from './config'\nimport debug from './debug'\n\nclass YouTubeReader extends Readable {\n  static fmtReg = /url_encoded_fmt_stream_map[\"']:\\s*[\"'](.+?)[\"']/\n  static adaptiveFmtReg = /adaptive_fmts[\"']:\\s*[\"'](.+?)[\"']/\n  static playerJSReg = /<script\\s* src=\"([^\"]+?player[^\"]+?\\.js)/\n\n  static qualityMap = {\n    18: '480p',\n    22: '720p',\n  }\n\n  static getDecryptedSignature = async function (html, s) {\n    const playerScriptResult = html.match(YouTubeReader.playerJSReg)\n    debug(`Video is like VEVO, with playerjs: ${playerScriptResult ? playerScriptResult[1] : 'Unknow'}`)\n    if (playerScriptResult) {\n      try {\n        const decryptedSig = await (new Signature(playerScriptResult[1])).decrypt(s)\n        return decryptedSig\n      } catch (e) { }\n    }\n    return ''\n  }\n\n  constructor(id, host) {\n    super()\n    if (!id) {\n      this.destroy(new NotFoundError())\n    }\n    this.id = id\n    this.host = host\n\n    this\n      .getDownloadLink()\n      .then(this.getAdaptiveFmt)\n    // .then(this.fetchVideo)\n      .then((targets) => {\n        this.push(JSON.stringify(targets))\n        this.push(null)\n      })\n      .catch((e) => {\n        if (!e && !(e instanceof NotFoundError)) {\n          console.error(`sth wrong with url ${this.url}`, e)\n        }\n      })\n  }\n\n  _read() {\n  }\n\n  _destroy(e) {\n    this.emit('error', e)\n  }\n\n  getDownloadLink() {\n    return new Promise((resolve, reject) => {\n      const url = `https://www.youtube.com/watch?v=${this.id}`\n      this.url = url\n      const options = parse(url)\n      if (proxy) {\n        const agent = new HttpsProxyAgent(proxy)\n        options.agent = agent\n      }\n\n      let tm\n      debug('Start fetching video html')\n      const req = request(options, (res) => {\n        if (res.statusCode > 300) {\n          debug(`HTML response error with statusCode ${res.statusCode}`)\n          const err = new NotFoundError()\n          this.destroy(err)\n          reject(err)\n        }\n        let html = ''\n        res.on('data', (chunk) => {\n          clearTimeout(tm)\n          html += chunk.toString()\n\n          tm = setTimeout(() => {\n            resolve(html)\n          }, 1000)\n        })\n        res.on('end', () => {\n          clearTimeout(tm)\n          resolve(html)\n        })\n      })\n      req.on('error', (e) => {\n        debug(`HTML fetch error: ${e ? e.name : 'Unknow error'}, ${e ? e.message : ''}`)\n        this.destroy(new RequestFailError(999))\n        reject(e)\n      })\n      req.end()\n    })\n  }\n\n  getAdaptiveFmt = async (html) => {\n    debug('Get adaptive fmt')\n    const result = html.match(YouTubeReader.adaptiveFmtReg)\n    if (!result) {\n      return this.getFmt(html)\n    }\n    const data = querystring.parse(result[1].replace(/\\\\u0026/g, '&'))\n    debug(`Adaptive data is \\n ${JSON.stringify(data, null, '\\t')}`)\n    const availableIndex = []\n    data.type.forEach((item, index) => {\n      if (item.startsWith('video/mp4')) {\n        availableIndex.push(index)\n      }\n    })\n\n    const targets = {}\n    await Promise.all(availableIndex.map(async (index) => {\n      let url = data.url[index]\n      const itag = data.itag[index]\n      let quality = data.quality_label\n\n      if (Array.isArray(quality)) {\n        // Normal situation\n        quality = data.quality_label[index].split(',')[0]\n      } else {\n        // Sometime quality return only 1080p\n        quality = `${data.size[index].split('x')[1]}p`\n      }\n      if (data.sp && (data.sp[index] === 'signature' || data.sp === 'signature')) {\n        const signature = await YouTubeReader.getDecryptedSignature(html, data.s[index])\n\n        if (signature) {\n          url = `${url}&signature=${signature}`\n        }\n      }\n\n      targets[quality] = {\n        url: this.getUrl(url),\n        itag,\n        quality,\n        size: Array.isArray(data.size) ?\n          data.size[index].split(',')[0] : data.size,\n      }\n    })).catch(e => { console.error(e) })\n\n    return Promise.resolve(this.getFmt(html, targets))\n  }\n\n  getFmt = async (html, targets = {}) => {\n    debug('Get fmt')\n    const result = html.match(YouTubeReader.fmtReg)\n\n    if (!result) {\n      debug('Video html not contain fmt info')\n      const err = new NotFoundError()\n      this.destroy(err)\n      return Promise.reject(err)\n    }\n\n    const types = result[1].split(',')\n\n    await Promise.all(types.map(async (t) => {\n      t = t.replace(/\\\\u0026/g, '&')\n      /* eslint-disable prefer-const */\n      let {\n        quality, itag, url,\n        type, s, sig, signature,\n      } = querystring.parse(t)\n      /* eslint-enable */\n\n      if (!YouTubeReader.qualityMap[itag]) {\n        return\n      }\n\n      if (targets[YouTubeReader.qualityMap[itag]]) {\n        return\n      }\n\n      if (sig || signature) {\n        url = `${url}&signature=${s || signature}`\n      } else if (s) {\n        const decrypted = await YouTubeReader.getDecryptedSignature(html, s)\n        if (decrypted) {\n          url = `${url}&signature=${decrypted}`\n        }\n      }\n\n      targets[YouTubeReader.qualityMap[itag]] = {\n        itag,\n        url: this.getUrl(url),\n        quality,\n        type,\n        size: '',\n      }\n    })).catch(e => console.error(e))\n    this.targets = targets\n    return Promise.resolve(targets)\n  }\n\n  getUrl = (url) => {\n    try{\n      const buff = Buffer.from(url)\n      return `${watchUrl.startsWith('http') ? watchUrl : 'http://' + this.host + watchUrl}?url=${buff.toString('base64')}`\n    } catch (e) {\n      console.log(`Base64 Error: ${url}`)\n      throw e\n    }\n  }\n\n  fetchVideo = () => {\n    const {url} = this.targets[22]\n    const options = parse(url)\n    if (proxy) {\n      const agent = new HttpsProxyAgent(proxy)\n      options.agent = agent\n    }\n    options.headers = {\n      'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:49.0) Gecko/20100101 Firefox/49.0',\n    }\n    debug('Start fetching video stream')\n    const req = request(options, (res) => {\n      if (res.statusCode >= 300) {\n        if (res.statusCode === 302) {\n          debug('Redirect to new location')\n          this.targets[22].url = res.headers.location\n          this.fetchVideo()\n        } else {\n          debug(`Video response error with statusCode ${res.statusCode}`)\n          this.destroy(new RequestFailError(res.statusCode))\n        }\n        return\n      }\n\n      const targetHeaders = [\n        'content-type', 'content-length', 'accept-ranges',\n        'content-range',\n      ]\n\n      this.emit('setHeader', targetHeaders.reduce((target, next) => {\n        if (res.headers[next]) {\n          target.push([next, res.headers[next]])\n        }\n        return target\n      }, []))\n\n      res.on('data', (chunk) => {\n        this.push(chunk)\n      })\n      res.on('end', () => {\n        debug('Stream fetched')\n        this.push(null)\n      })\n    })\n    req.end()\n  }\n}\n\nexport function loadVideo(id, host) {\n  debug(`Get youtube video with id: ${id}`)\n  const stream = new YouTubeReader(id, host)\n  return stream\n}\n"]}